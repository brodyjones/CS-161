##############
# Homework 2 #
##############


###################
# Read This First #
###################


# All functions that you need to modify are marked with 'EXERCISE' in their header comments.
# Do not modify astar.py
# This file also contains many helper functions. You may call any of them in your functions.


# Due to the memory limitation, the A* algorithm may crash on some hard sokoban problems if too many
# nodes are generated. Improving the quality of the heuristic will mitigate
# this problem, as it will allow A* to solve hard problems with fewer node expansions.


# Remember that most functions are not graded on efficiency (only correctness).
# Efficiency can only influence your heuristic performance in the competition (which will affect your score).


# Load the astar.py and do not modify it.
import astar
# Load the numpy package and the state is represented as a numpy array during this homework.
import numpy as np


# a_star perform the A* algorithm with the start_state (numpy array), goal_test (function), successors (function) and
# heuristic (function). a_star prints the solution from start_state to goal_state (path), calculates the number of
# generated nodes (node_generated) and expanded nodes (node_expanded), and the solution depth (len(path)-1). a_star
# also provides the following functions for printing states and moves: prettyMoves(path): Translate the solution to a
# list of moves printlists(path): Visualize the solution and Print a list of states
def a_star(start_state, goal_test, successors, heuristic):
    goal_node, node_generated, node_expanded = astar.a_star_search(start_state, goal_test, successors, heuristic)
    if goal_node:
        node = goal_node
        path = [node.state1]
        while node.parent:
            node = node.parent
            path.append(node.state1)
        path.reverse()

        # print('My path:{}'.format(path))
        # print(prettyMoves(path))
        # printlists(path)
        print('Nodes Generated by A*: {}'.format(node_generated))
        print('Nodes Expanded by A*: {}'.format(node_expanded))
        print('Solution Depth: {}'.format(len(path) - 1))
    else:
        print('no solution found')


# A shortcut function
# Transform the input state to numpy array. For other functions, the state s is presented as a numpy array.
# Goal-test and next-states stay the same throughout the assignment
# You can just call sokoban(init-state, heuristic function) to test the result
def sokoban(s, h):
    return a_star(np.array(s), goal_test, next_states, h)


# Define some global variables
blank = 0
wall = 1
box = 2
keeper = 3
star = 4
boxstar = 5
keeperstar = 6


# Some helper functions for checking the content of a square
def isBlank(v):
    return (v == blank)


def isWall(v):
    return (v == wall)


def isBox(v):
    return (v == box)


def isKeeper(v):
    return (v == keeper)


def isStar(v):
    return (v == star)


def isBoxstar(v):
    return (v == boxstar)


def isKeeperstar(v):
    return (v == keeperstar)


# Help function for get KeeperPosition
# Given state s (numpy array), return the position of the keeper by row, col
# The top row is the zeroth row
# The first (right) column is the zeroth column
def getKeeperPosition(s):
    row = s.shape[0]
    col = s.shape[1]
    for i in range(row):
        for j in range(col):
            if (isKeeper(s[i, j]) or isKeeperstar(s[i, j])):
                return i, j


# For input list s_list, remove all None element
# For example, if s_list = [1, 2, None, 3], returns [1, 2, 3]
def cleanUpList(s_list):
    clean = []
    for state in s_list:
        if state is not None:
            clean.append(state)
    return clean


# EXERCISE: Modify this function to return Ture
# if and only if s (numpy array) is a goal state of a Sokoban game.
# (no box is on a non-goal square)
# Remember, the number of goal can be larger than the number of box.
# Currently, it always returns False. If A* is called with
# this function as the goal testing function, A* will never
# terminate until the whole search space is exhausted.
def goal_test(s):
    i = 0
    while i < len(s):
        j = 0
        while j < len(s[i]): # iterate through every position in the game
            if isBox(s[i][j]): # if any box is not on a star then return false
                return False
            j += 1
        i += 1
    return True # else return true


# EXERCISE: Modify this function to return the list of
# successor states of s (numpy array).
#
# This is the top-level next-states (successor) function.
# Some skeleton code is provided below.
# You may delete them totally, depending on your approach.
# 
# If you want to use it, you will need to set 'result' to be 
# the set of states after moving the keeper in each of the 4 directions.
#
# You can define the function try-move and decide how to represent UP,DOWN,LEFT,RIGHT.
# Any None result in the list can be removed by cleanUpList.
#
# When generated the successors states, you may need to copy the current state s (numpy array).
# A shallow copy (e.g, direcly set s1 = s) constructs a new compound object and then inserts references 
# into it to the objects found in the original. In this case, any change in the numpy array s1 will also affect
# the original array s. Thus, you may need a deep copy (e.g, s1 = np.copy(s)) to construct an indepedent array.

# define some more globals

def next_states(s):
    # row, col = getKeeperPosition(s)

    UP = 0
    DOWN = 1
    LEFT = 2
    RIGHT = 3

    s_list = []
    s1 = np.copy(s)
    
    s_list.append(try_move(s1, UP))
    s_list.append(try_move(s1, DOWN))
    s_list.append(try_move(s1, LEFT))
    s_list.append(try_move(s1, RIGHT))


    return cleanUpList(s_list)

def try_move(s1, dir):

    UP = 0
    DOWN = 1
    LEFT = 2
    RIGHT = 3

    s = np.copy(s1)

    row, col = getKeeperPosition(s)

    if dir == UP:
        if row == 0:
            return None
        row -= 1
        if isWall(s[row][col]): # tries to move into a wall
            return None
        if isBox(s[row][col]) or isBoxstar(s[row][col]):
            if row == 0:
                return None
            if isBox(s[row-1][col]) or isBoxstar(s[row-1][col]) or isWall(s[row-1][col]):
                return None
            if isStar(s[row-1][col]): # if space ahead of box is a star, then move the box there
                s[row-1][col] = boxstar
            if isBlank(s[row-1][col]):# if space ahead of box is a blank, then move the box there
                s[row-1][col] = box

            if isBox(s[row][col]): # fill in box's old position with the appropriate symbol
                s[row][col] = blank
            if isBoxstar(s[row][col]):
                s[row][col] = star

        if isBlank(s[row][col]): # if moving into a blank, then move the keeper and fill in its previous position
            s[row][col] = keeper
            if isKeeper(s[row+1][col]): 
                s[row+1][col] = blank
            else:
                s[row+1][col] = star
        if isStar(s[row][col]): # if moving into a star, then move the keeper and fill in its previous position
            s[row][col] = keeperstar
            if isKeeper(s[row+1][col]): 
                s[row+1][col] = blank
            else:
                s[row+1][col] = star


    if dir == DOWN:
        if row == (len(s) - 1):
            return None
        row += 1
        if isWall(s[row][col]): # tries to move into a wall
            return None
        if isBox(s[row][col]) or isBoxstar(s[row][col]):
            if row == (len(s) - 1):
                return None
            if isBox(s[row+1][col]) or isBoxstar(s[row+1][col]) or isWall(s[row+1][col]):
                return None
            if isStar(s[row+1][col]): # if space ahead of box is a star, then move the box there
                s[row+1][col] = boxstar
            if isBlank(s[row+1][col]):# if space ahead of box is a blank, then move the box there
                s[row+1][col] = box

            if isBox(s[row][col]): # fill in box's old position with the appropriate symbol
                s[row][col] = blank
            if isBoxstar(s[row][col]):
                s[row][col] = star

        if isBlank(s[row][col]): # if moving into a blank, then move the keeper and fill in its previous position
            s[row][col] = keeper
            if isKeeper(s[row-1][col]): 
                s[row-1][col] = blank
            else:
                s[row-1][col] = star
        if isStar(s[row][col]): # if moving into a star, then move the keeper and fill in its previous position
            s[row][col] = keeperstar
            if isKeeper(s[row-1][col]): 
                s[row-1][col] = blank
            else:
                s[row-1][col] = star

    if dir == LEFT:
        if col == 0:
            return None
        col -= 1
        if isWall(s[row][col]): # tries to move into a wall
            return None
        if isBox(s[row][col]) or isBoxstar(s[row][col]):
            if col == 0:
                return None
            if isBox(s[row][col-1]) or isBoxstar(s[row][col-1]) or isWall(s[row][col-1]):
                return None
            if isStar(s[row][col-1]): # if space ahead of box is a star, then move the box there
                s[row][col-1] = boxstar
            if isBlank(s[row][col-1]):# if space ahead of box is a blank, then move the box there
                s[row][col-1] = box

            if isBox(s[row][col]): # fill in box's old position with the appropriate symbol
                s[row][col] = blank
            if isBoxstar(s[row][col]):
                s[row][col] = star

        if isBlank(s[row][col]): # if moving into a blank, then move the keeper and fill in its previous position
            s[row][col] = keeper
            if isKeeper(s[row][col+1]): 
                s[row][col+1] = blank
            else:
                s[row][col+1] = star
        if isStar(s[row][col]): # if moving into a star, then move the keeper and fill in its previous position
            s[row][col] = keeperstar
            if isKeeper(s[row][col+1]): 
                s[row][col+1] = blank
            else:
                s[row][col+1] = star


    if dir == RIGHT:
        if col == (len(s[0]) - 1):
            return None
        col += 1
        if isWall(s[row][col]): # tries to move into a wall
            return None
        if isBox(s[row][col]) or isBoxstar(s[row][col]):
            if col == (len(s[0]) - 1):
                return None
            if isBox(s[row][col+1]) or isBoxstar(s[row][col+1]) or isWall(s[row][col+1]):
                return None
            if isStar(s[row][col+1]): # if space ahead of box is a star, then move the box there
                s[row][col+1] = boxstar
            if isBlank(s[row][col+1]):# if space ahead of box is a blank, then move the box there
                s[row][col+1] = box

            if isBox(s[row][col]): # fill in box's old position with the appropriate symbol
                s[row][col] = blank
            if isBoxstar(s[row][col]):
                s[row][col] = star

        if isBlank(s[row][col]): # if moving into a blank, then move the keeper and fill in its previous position
            s[row][col] = keeper
            if isKeeper(s[row][col-1]): 
                s[row][col-1] = blank
            else:
                s[row][col-1] = star
        if isStar(s[row][col]): # if moving into a star, then move the keeper and fill in its previous position
            s[row][col] = keeperstar
            if isKeeper(s[row][col-1]): 
                s[row][col-1] = blank
            else:
                s[row][col-1] = star

    return s



# EXERCISE: Modify this function to compute the trivial
# admissible heuristic.
def h0(s):
    return 0


# EXERCISE: Modify this function to compute the
# number of misplaced boxes in state s (numpy array).
def h1(s):
    count = 0
    i = 0
    while i < s.shape[0]:
        j = 0
        while j < s.shape[1]:
            if isBox(s[i][j]): # for each box in the map, increment the count
                count += 1
            j += 1
        i += 1
    return count


# EXERCISE: Change the name of this function to h<UID> where
# <UID> is your actual student ID number. Then, modify this 
# function to compute an admissible heuristic value of s. 
# For example, if my UID is 123456789, then I should change the function name to 'h123456789'
# This function will be tested in various hard examples.
# Objective: make A* solve problems as fast as possible.

def h905762155(s):
    count = 0
    i = 0
    while i < s.shape[0]:
        j = 0
        while j < s.shape[1]:
            if isBox(s[i][j]):
                count += bfs(s, [(i, j, 0)]) # returns the length of the shortest path to the star
            j += 1
        i += 1
    return count # count is the sum of all pathlengths for every box in the game



def bfs(s, next_states): # returns the shortest path to a star state via bfs
    visited = [] # track which states we have checked already
    found_path = [] # track path lengths for when we find a path
    while next_states:
        # print(next_states)
        state = next_states.pop(0) # state is a tuple with values (row, column, path_length)
        r = state[0]
        c = state[1]
        visited.append((r, c))

        if s[r][c] == star:
            # print("found star")
            found_path.append(state[2]) # if we found a star then append the path length
            continue
        if r != (len(s)-1) and not isWall(s[r+1][c]) and (r+1, c) not in visited:
            next_states.append((r+1, c, state[2]+1))
        if c != (len(s[0])-1) and not isWall(s[r][c+1]) and (r, c+1) not in visited:
            next_states.append((r, c+1, state[2]+1))
        if r != 0 and not isWall(s[r-1][c]) and (r-1, c) not in visited:
            next_states.append((r-1, c, state[2]+1))
        if c != 0 and not isWall(s[r][c-1]) and (r, c-1) not in visited:
            next_states.append((r, c-1, state[2]+1))

        # for each surrounding position, if it is not an illegal move and has not been visited yet
        # then add it to the list of states to expand
    
    if len(found_path) == 0:
        return (len(s)-1)*(len(s[0])-1)
    else:
        return min(found_path) # return the minimum length path
    

        





# Some predefined problems with initial state s (array). Sokoban function will automatically transform it to numpy
# array. For other function, the state s is presented as a numpy array. You can just call sokoban(init-state,
# heuristic function) to test the result Each problem can be visualized by calling prettyMoves(path) and printlists(
# path) in a_star function
#
# Problems are roughly ordered by their difficulties.
# For most problems, we also provide 2 additional number per problem:
#    1) # of nodes expanded by A* using our next-states and h0 heuristic.
#    2) the depth of the optimal solution.
# These numbers are located at the comments of the problems. For example, the first problem below 
# was solved by 80 nodes expansion of A* and its optimal solution depth is 7.
# 
# Your implementation may not result in the same number of nodes expanded, but it should probably
# give something in the same ballpark. As for the solution depth, any admissible heuristic must 
# make A* return an optimal solution. So, the depths of the optimal solutions provided could be used
# for checking whether your heuristic is admissible.
#
# Warning: some problems toward the end are quite hard and could be impossible to solve without a good heuristic!


# [80,7]
s1 = [[1, 1, 1, 1, 1, 1],
      [1, 0, 3, 0, 0, 1],
      [1, 0, 2, 0, 0, 1],
      [1, 1, 0, 1, 1, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 0, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1]]

# [110,10],
s2 = [[1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 1],
      [1, 0, 0, 0, 0, 0, 1],
      [1, 0, 0, 2, 1, 4, 1],
      [1, 3, 0, 0, 1, 0, 1],
      [1, 1, 1, 1, 1, 1, 1]]

# [211,12],
s3 = [[1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 0, 0, 0, 2, 0, 3, 4, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [300,13],
s4 = [[1, 1, 1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0, 1, 4],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 1, 1, 1, 0, 0],
      [0, 0, 1, 0, 0, 0, 0],
      [0, 2, 1, 0, 0, 0, 0],
      [0, 3, 1, 0, 0, 0, 0]]

# [551,10],
s5 = [[1, 1, 1, 1, 1, 1],
      [1, 1, 0, 0, 1, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 4, 2, 2, 4, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 1, 3, 1, 1, 1],
      [1, 1, 1, 1, 1, 1]]

# [722,12],
s6 = [[1, 1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 4, 1],
      [1, 0, 0, 0, 2, 2, 3, 1],
      [1, 0, 0, 1, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1, 1, 1]]

# [1738,50],
s7 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [0, 0, 1, 1, 1, 1, 0, 0, 0, 3],
      [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
      [0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
      [0, 2, 1, 0, 0, 0, 0, 0, 1, 0],
      [0, 0, 1, 0, 0, 0, 0, 0, 1, 4]]

# [1763,22],
s8 = [[1, 1, 1, 1, 1, 1],
      [1, 4, 0, 0, 4, 1],
      [1, 0, 2, 2, 0, 1],
      [1, 2, 0, 1, 0, 1],
      [1, 3, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1]]

# [1806,41],
s9 = [[1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 0, 0, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 2, 0, 1],
      [1, 0, 1, 0, 0, 1, 2, 0, 1],
      [1, 0, 4, 0, 4, 1, 3, 0, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [10082,51],
s10 = [[1, 1, 1, 1, 1, 0, 0],
       [1, 0, 0, 0, 1, 1, 0],
       [1, 3, 2, 0, 0, 1, 1],
       [1, 1, 0, 2, 0, 0, 1],
       [0, 1, 1, 0, 2, 0, 1],
       [0, 0, 1, 1, 0, 0, 1],
       [0, 0, 0, 1, 1, 4, 1],
       [0, 0, 0, 0, 1, 4, 1],
       [0, 0, 0, 0, 1, 4, 1],
       [0, 0, 0, 0, 1, 1, 1]]

# [16517,48],
s11 = [[1, 1, 1, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 4, 1],
       [1, 0, 2, 2, 1, 0, 1],
       [1, 0, 2, 0, 1, 3, 1],
       [1, 1, 2, 0, 1, 0, 1],
       [1, 4, 0, 0, 4, 0, 1],
       [1, 1, 1, 1, 1, 1, 1]]

# [22035,38],
s12 = [[0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1],
       [1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1],
       [1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 2, 1, 1, 1, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 1, 0, 1, 4, 0, 4, 1],
       [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1]]

# [26905,28],
s13 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 0, 0, 2, 0, 1],
       [1, 0, 2, 0, 0, 0, 0, 0, 4, 1],
       [1, 0, 3, 0, 0, 0, 0, 0, 2, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 4, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [41715,53],
s14 = [[0, 0, 1, 0, 0, 0, 0],
       [0, 2, 1, 4, 0, 0, 0],
       [0, 2, 0, 4, 0, 0, 0],
       [3, 2, 1, 1, 1, 0, 0],
       [0, 0, 1, 4, 0, 0, 0]]

# [48695,44],
s15 = [[1, 1, 1, 1, 1, 1, 1],
       [1, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 2, 2, 0, 1],
       [1, 0, 2, 0, 2, 3, 1],
       [1, 4, 4, 1, 1, 1, 1],
       [1, 4, 4, 1, 0, 0, 0],
       [1, 1, 1, 1, 0, 0, 0]]

# [91344,111],
s16 = [[1, 1, 1, 1, 1, 0, 0, 0],
       [1, 0, 0, 0, 1, 0, 0, 0],
       [1, 2, 1, 0, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 5, 0, 5, 0, 1],
       [1, 0, 5, 0, 1, 0, 1, 1],
       [1, 1, 1, 0, 3, 0, 1, 0],
       [0, 0, 1, 1, 1, 1, 1, 0]]

# [3301278,76],
# Warning: This problem is very hard and could be impossible to solve without a good heuristic!
s17 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 3, 0, 0, 1, 0, 0, 0, 4, 1],
       [1, 0, 2, 0, 2, 0, 0, 4, 4, 1],
       [1, 0, 2, 2, 2, 1, 1, 4, 4, 1],
       [1, 0, 0, 0, 0, 1, 1, 4, 4, 1],
       [1, 1, 1, 1, 1, 1, 0, 0, 0, 0]]

# [??,25],
s18 = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 4, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 4, 1, 0, 0, 0, 0]]

# [??,21],
s19 = [[0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],
       [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0],
       [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 4],
       [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 2, 0, 4, 1, 0, 0, 0]]


# Utility functions for printing states and moves.
# You do not need to understand any of the functions below this point.


# Helper function of prettyMoves
# Detect the move from state s --> s1
def detectDiff(s, s1):
    row, col = getKeeperPosition(s)
    row1, col1 = getKeeperPosition(s1)
    if (row1 == row + 1):
        return 'Down'
    if (row1 == row - 1):
        return 'Up'
    if (col1 == col + 1):
        return 'Right'
    if (col1 == col - 1):
        return 'Left'
    return 'fail'


# Translates a list of states into a list of moves
def prettyMoves(lists):
    initial = 0
    action = []
    for states in (lists):
        if (initial != 0):
            action.append(detectDiff(previous, states))
        initial = 1
        previous = states
    return action


# Print the content of the square to stdout.
def printsquare(v):
    if (v == blank):
        print(' ', end='')
    if (v == wall):
        print('#', end='')
    if (v == box):
        print('$', end='')
    if (v == keeper):
        print('@', end='')
    if (v == star):
        print('.', end='')
    if (v == boxstar):
        print('*', end='')
    if (v == keeperstar):
        print('+', end='')


# Print a state
def printstate(s):
    row = s.shape[0]
    col = s.shape[1]
    for i in range(row):
        for j in range(col):
            printsquare(s[i, j])
        print('\n')


# Print a list of states with delay.
def printlists(lists):
    for states in (lists):
        printstate(states)
        print('\n')


s_test = [[1, 1, 1, 1, 1, 1],
      [1, 0, 3, 0, 0, 1],
      [1, 0, 2, 0, 0, 1],
      [1, 1, 0, 1, 1, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 0, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1]]

if __name__ == "__main__":
    # print(next_states(s_test))
    sokoban(s15, h905762155)
